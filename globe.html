<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Interactive 3D Globe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three-globe"></script>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #f3f2ed;
        width: 100%;
        height: 100%;
    }
    #globe-container {
        width: 100vw;
        height: 100vh;
        background: #f3f2ed;
    }
    .label {
        position: absolute;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 14px;
        font-weight: bold;
        padding: 4px 8px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 4px;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }
</style>
</head>
<body>
<div id="globe-container"></div>
<script>
const EARTH_DAY_URL    = "https://vedant1424.github.io/globe-project/8k_earth_daymap.jpg";
const EARTH_NORMAL_URL = "https://vedant1424.github.io/globe-project/8k_earth_normalmap.jpg";

// Setup
const container = document.getElementById("globe-container");
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.z = 280;

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setClearColor(0x000000, 0);
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
directionalLight.position.set(5, 3, 5);
scene.add(directionalLight);

// Globe - larger size
const globe = new ThreeGlobe()
    .globeImageUrl(EARTH_DAY_URL)
    .bumpImageUrl(EARTH_NORMAL_URL)
    .showAtmosphere(true)
    .atmosphereColor("#00d4ff")
    .atmosphereAltitude(0.25);

// Scale up the globe
globe.scale.set(1.4, 1.4, 1.4);
scene.add(globe);

// Professional markers for India & Iran
const markers = [
    { lat: 20.5937, lng: 78.9629, size: 0.8, color: "#ff3333", label: "India" },
    { lat: 32.4279, lng: 53.6880, size: 0.8, color: "#ff3333", label: "Iran" }
];

globe
    .pointsData(markers)
    .pointLat("lat")
    .pointLng("lng")
    .pointAltitude(0.01)
    .pointColor("color")
    .pointRadius("size")
    .pointResolution(32);

// Add custom marker rings for better visibility
markers.forEach(marker => {
    const phi = (90 - marker.lat) * (Math.PI / 180);
    const theta = (marker.lng + 180) * (Math.PI / 180);
    const radius = 100 * 1.4 + 1;
    
    const x = -(radius * Math.sin(phi) * Math.cos(theta));
    const y = radius * Math.cos(phi);
    const z = radius * Math.sin(phi) * Math.sin(theta);
    
    // Outer glow ring
    const ringGeometry = new THREE.RingGeometry(1.5, 2.5, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0xff3333,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.6
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.set(x, y, z);
    ring.lookAt(0, 0, 0);
    globe.add(ring);
    
    // Pulsing animation
    let scale = 1;
    let growing = true;
    function animateRing() {
        if (growing) {
            scale += 0.01;
            if (scale >= 1.3) growing = false;
        } else {
            scale -= 0.01;
            if (scale <= 1) growing = true;
        }
        ring.scale.set(scale, scale, 1);
    }
    ring.userData.animate = animateRing;
});

// Enhanced rotation with momentum
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let velocity = { x: 0, y: 0 };
let autoRotateSpeed = 0.003;

renderer.domElement.addEventListener('mousedown', (e) => {
    isDragging = true;
    velocity = { x: 0, y: 0 };
    previousMousePosition = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener('mousemove', (e) => {
    if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        velocity.x = deltaY * 0.01;
        velocity.y = deltaX * 0.01;
        
        globe.rotation.x += velocity.x;
        globe.rotation.y += velocity.y;
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }
});

renderer.domElement.addEventListener('mouseup', () => {
    isDragging = false;
});

renderer.domElement.addEventListener('mouseleave', () => {
    isDragging = false;
});

// Zoom with mouse wheel
renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault();
    camera.position.z += e.deltaY * 0.15;
    camera.position.z = Math.max(180, Math.min(500, camera.position.z));
});

// Touch support for mobile
let touchStartDistance = 0;
let lastTouchPosition = { x: 0, y: 0 };

renderer.domElement.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
        isDragging = true;
        velocity = { x: 0, y: 0 };
        lastTouchPosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchStartDistance = Math.sqrt(dx * dx + dy * dy);
    }
});

renderer.domElement.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;
        
        velocity.x = deltaY * 0.01;
        velocity.y = deltaX * 0.01;
        
        globe.rotation.x += velocity.x;
        globe.rotation.y += velocity.y;
        
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const delta = distance - touchStartDistance;
        camera.position.z -= delta * 0.5;
        camera.position.z = Math.max(180, Math.min(500, camera.position.z));
        touchStartDistance = distance;
    }
});

renderer.domElement.addEventListener('touchend', () => {
    isDragging = false;
});

// Animation with momentum
function animate() {
    requestAnimationFrame(animate);
    
    if (!isDragging) {
        // Apply momentum decay
        velocity.x *= 0.95;
        velocity.y *= 0.95;
        
        // Always rotate with base speed + momentum
        globe.rotation.y += autoRotateSpeed + velocity.y;
        globe.rotation.x += velocity.x;
        
        // Clamp X rotation to prevent flipping
        globe.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, globe.rotation.x));
    }
    
    // Animate marker rings
    globe.children.forEach(child => {
        if (child.userData.animate) {
            child.userData.animate();
        }
    });
    
    renderer.render(scene, camera);
}
animate();

// Responsive
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
