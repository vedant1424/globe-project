<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Interactive 3D Globe</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three-globe"></script>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        width: 100%;
        height: 100%;
    }
    #globe-container {
        width: 100vw;
        height: 100vh;
        background: black;
    }
</style>
</head>
<body>
<div id="globe-container"></div>
<script>
const EARTH_DAY_URL    = "https://vedant1424.github.io/globe-project/8k_earth_daymap.jpg";
const EARTH_NORMAL_URL = "https://vedant1424.github.io/globe-project/8k_earth_normalmap.jpg";

// Setup
const container = document.getElementById("globe-container");
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.z = 380;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 3, 5);
scene.add(directionalLight);

// Globe
const globe = new ThreeGlobe()
    .globeImageUrl(EARTH_DAY_URL)
    .bumpImageUrl(EARTH_NORMAL_URL)
    .showAtmosphere(true)
    .atmosphereColor("cyan")
    .atmosphereAltitude(0.22);
scene.add(globe);

// Markers for India & Iran
const markers = [
    { lat: 20.5937, lng: 78.9629, size: 0.02, color: "red", label: "India" },
    { lat: 32.4279, lng: 53.6880, size: 0.02, color: "red", label: "Iran" }
];

globe
    .pointsData(markers)
    .pointLat("lat")
    .pointLng("lng")
    .pointAltitude(0.02)
    .pointColor("color")
    .pointRadius("size");

// Simple manual orbit controls
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let rotation = { x: 0, y: 0 };
let autoRotate = true;

renderer.domElement.addEventListener('mousedown', (e) => {
    isDragging = true;
    autoRotate = false;
    previousMousePosition = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener('mousemove', (e) => {
    if (isDragging) {
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;
        
        rotation.y += deltaX * 0.005;
        rotation.x += deltaY * 0.005;
        
        previousMousePosition = { x: e.clientX, y: e.clientY };
    }
});

renderer.domElement.addEventListener('mouseup', () => {
    isDragging = false;
});

renderer.domElement.addEventListener('mouseleave', () => {
    isDragging = false;
});

// Zoom with mouse wheel
renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault();
    camera.position.z += e.deltaY * 0.1;
    camera.position.z = Math.max(200, Math.min(600, camera.position.z));
});

// Touch support for mobile
let touchStartDistance = 0;
renderer.domElement.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
        isDragging = true;
        autoRotate = false;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchStartDistance = Math.sqrt(dx * dx + dy * dy);
    }
});

renderer.domElement.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1 && isDragging) {
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;
        
        rotation.y += deltaX * 0.005;
        rotation.x += deltaY * 0.005;
        
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const delta = distance - touchStartDistance;
        camera.position.z -= delta * 0.5;
        camera.position.z = Math.max(200, Math.min(600, camera.position.z));
        touchStartDistance = distance;
    }
});

renderer.domElement.addEventListener('touchend', () => {
    isDragging = false;
});

// Animation
function animate() {
    requestAnimationFrame(animate);
    
    if (autoRotate) {
        globe.rotation.y += 0.0016;
    } else {
        globe.rotation.y = rotation.y;
        globe.rotation.x = rotation.x;
    }
    
    renderer.render(scene, camera);
}
animate();

// Responsive
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
